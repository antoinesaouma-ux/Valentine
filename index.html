<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pour toi ðŸ’˜</title>
  <style>
    :root{
      --bg: #0f1020;
      --card-bg: linear-gradient(180deg,#161626 0%, #0f1120 100%);
      --text: #ecebf6;
      --muted: #9b9bb3;
      --accent: #ff6fa3;
      --cat-scale: 4;          /* Ã©chelle par dÃ©faut des sprites (modifie si besoin) */
      --frames-per-row: 8;     /* colonnes connues de ta sprite-sheet */
      --default-frame-w: 32;   /* fallback si auto-dÃ©tection Ã©choue */
      --default-frame-h: 32;
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Arial,Helvetica;display:flex;align-items:center;justify-content:center;}
    .container{
      width:min(820px,92vw);
      padding:36px;
    }

    .card{
      background:var(--card-bg);
      border-radius:16px;
      padding:28px;
      box-shadow: 0 8px 30px rgba(3,6,23,0.6);
      position:relative;
      overflow:visible;
    }
    h1{margin:0 0 12px 0;font-size:20px}
    p.lead{margin:0 0 16px;color:var(--muted)}

    .actions{display:flex;gap:12px;align-items:center;margin-top:14px}
    button.btn{
      background:transparent;
      color:var(--text);
      border:1px solid rgba(255,255,255,0.06);
      padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600;
    }
    button.btn.yes{background:linear-gradient(90deg,var(--accent),#ff8fb3);color:#0b0720;border:none}
    button.btn:disabled{opacity:0.6;cursor:default}

    /* toast simple */
    .toast{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:28px;
      background:rgba(0,0,0,0.45);
      color:var(--text);
      padding:10px 16px;border-radius:10px;font-weight:600;backdrop-filter: blur(4px);
      opacity:0;transition:opacity 220ms ease;pointer-events:none;z-index:1100;
    }
    .toast.show{opacity:1;pointer-events:auto}

    /* GIF de cÃ©lÃ©bration (apparaÃ®t au-dessus du message) */
    .celebration-gif{
      position:absolute;
      left:50%;
      transform:translateX(-50%) translateY(-8px);
      pointer-events:none;
      width:160px;
      max-width:40vw;
      opacity:0;
      transition: opacity 260ms ease, transform 260ms ease;
      z-index:99999;
      filter: drop-shadow(0 8px 22px rgba(0,0,0,0.45));
    }
    .celebration-gif.show{opacity:1;transform:translateX(-50%) translateY(0)}

    /* container pour chats (occupant tout l'Ã©cran pour faciliter position ABS) */
    .stage{
      position:fixed;
      inset:0;
      pointer-events:none; /* ne pas bloquer la souris */
      z-index:50;
      overflow:visible;
    }
    /* classe appliquÃ©e Ã  chaque chat (taille / sprite background) */
    .cat{
      position:absolute;
      width:32px; /* sera recalculÃ© par JS via scale */
      height:32px;
      background-image:url("image/cat.png");
      background-repeat:no-repeat;
      image-rendering: pixelated;
      will-change: transform, background-position;
      transform-origin: left top;
      pointer-events:none;
    }
    /* petit conseil responsive */
    @media (max-width:420px){
      .celebration-gif{width:120px}
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card" id="card">
      <h1>Veux-tu Ãªtre ma Valentine ? ðŸ’Œ</h1>
      <p class="lead">J'ai prÃ©parÃ© une petite surprise â€” dÃ©place la souris pour voir des chats et clique "Oui" si tu aimes.</p>

      <div class="actions">
        <button class="btn yes" id="yesBtn">Oui</button>
        <button class="btn" id="noBtn">Non</button>
      </div>
    </div>
  </div>

  <div class="stage" id="stage" aria-hidden="true"></div>
  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script>
    /* ----------------------------
       Configuration minimale
       Modifie si besoin : CAT_SCALE, FRAMES_PER_ROW
       ---------------------------- */
    const CSS_CAT_SCALE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cat-scale')) || 4;
    const FRAMES_PER_ROW = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--frames-per-row')) || 8;
    const SHEET_SRC = 'image/cat.png'; // chemin vers la sprite
    const GIF_SRC = 'image/love-mochi.gif'; // chemin vers le gif de cÃ©lÃ©bration

    /* Ã©lÃ©ments UI */
    const yesBtn = document.getElementById('yesBtn');
    const noBtn = document.getElementById('noBtn');
    const toastEl = document.getElementById('toast');
    const stage = document.getElementById('stage');
    const card = document.getElementById('card');

    /* helper toast */
    function showToast(text, ms = 1500){
      toastEl.textContent = text;
      toastEl.classList.add('show');
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=> toastEl.classList.remove('show'), ms);
    }

    /* ----------------------------
       Sprite-sheet auto-dÃ©tection
       Charge l'image et calcule frameW/frameH/rows
       ---------------------------- */
    let SHEET_NAT_W = 0, SHEET_NAT_H = 0;
    let FRAME_W = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--default-frame-w')) || 32;
    let FRAME_H = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--default-frame-h')) || 32;
    let SHEET_ROWS = 1;
    let TOTAL_FRAMES = null; // si tu connais, mets le nombre total sinon null

    function initSpriteSheet(){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.src = SHEET_SRC + '?_=' + Date.now(); // bust cache en dev
        img.onload = () => {
          SHEET_NAT_W = img.naturalWidth;
          SHEET_NAT_H = img.naturalHeight;

          // si TOTAL_FRAMES connu, on calcule frameH via cols/rows ; sinon on suppose toutes les frames ont la mÃªme largeur = natWidth / FRAMES_PER_ROW
          FRAME_W = Math.round(SHEET_NAT_W / FRAMES_PER_ROW) || FRAME_W;
          FRAME_H = FRAME_W; // souvent sprites carrÃ©s ; sinon on essaye d'infÃ©rer via height
          // calc rows Ã  partir de hauteur
          SHEET_ROWS = Math.round(SHEET_NAT_H / FRAME_H) || Math.max(1, Math.round(SHEET_NAT_H / FRAME_W));
          // si rÃ©sultat incohÃ©rent (p.ex. margins), on ajuste en recoupant
          if (SHEET_ROWS * FRAME_H > SHEET_NAT_H){
            // ajuste frameH pour correspondre exactement
            FRAME_H = Math.floor(SHEET_NAT_H / SHEET_ROWS);
          }

          // fallback si quelque chose cloche
          if (!FRAME_W || !FRAME_H){
            FRAME_W = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--default-frame-w')) || 32;
            FRAME_H = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--default-frame-h')) || 32;
            SHEET_ROWS = Math.max(1, Math.round(SHEET_NAT_H / FRAME_H));
          }

          // stocker pour debug
          console.info('sprite loaded', {SHEET_NAT_W, SHEET_NAT_H, FRAME_W, FRAME_H, FRAMES_PER_ROW, SHEET_ROWS});
          resolve();
        };
        img.onerror = () => reject(new Error('Impossible de charger la sprite : ' + SHEET_SRC));
      });
    }

    /* ----------------------------
       CrÃ©ation d'un chat (Ã©lÃ©ment DOM) :
       - calcule background-size et position en pixels exacts pour Ã©viter de voir la sheet entiÃ¨re
       - gÃ¨re une animation simple (frames) et mouvement de fuite horizontal
       ---------------------------- */
    let cats = [];
    function createCat({x=100, y=200, animRow=0, frames=4, speed=120} = {}){
      const el = document.createElement('div');
      el.className = 'cat';
      // taille en px aprÃ¨s scale
      const SCALE = CSS_CAT_SCALE || 4;
      const w = FRAME_W * SCALE;
      const h = FRAME_H * SCALE;
      el.style.width = w + 'px';
      el.style.height = h + 'px';
      // background-size : taille rÃ©elle de l'image multipliÃ©e par scale pour que chaque frame corresponde
      const bgW = SHEET_NAT_W * SCALE;
      const bgH = SHEET_NAT_H * SCALE;
      el.style.backgroundSize = `${bgW}px ${bgH}px`;
      // initial frame index
      el._frameIndex = 0;
      el._frames = frames;
      el._row = animRow;
      el._speed = speed; // ms per frame
      el._lastFrameTime = performance.now();
      // compute initial background-position
      const bx = -(el._frameIndex * FRAME_W * SCALE);
      const by = -(el._row * FRAME_H * SCALE);
      el.style.backgroundPosition = `${bx}px ${by}px`;

      // position
      el.style.transform = `translate(${x}px, ${y}px) scale(${SCALE}) translateZ(0)`;
      // store logical pos (in px unscaled)
      el._x = x;
      el._y = y;

      // animation loop
      function tick(now){
        // frame animation
        if (now - el._lastFrameTime >= el._speed){
          el._frameIndex = (el._frameIndex + 1) % el._frames;
          el._lastFrameTime = now;
          const bx = -(el._frameIndex * FRAME_W * SCALE);
          const by = -(el._row * FRAME_H * SCALE);
          el.style.backgroundPosition = `${bx}px ${by}px`;
        }
        // movement: simple random small wobble (cats fuient via updateFlee)
        if (el._raf) el._raf = requestAnimationFrame(tick);
      }
      el._raf = requestAnimationFrame(tick);

      // append
      stage.appendChild(el);
      el.destroy = () => { cancelAnimationFrame(el._raf); el.remove(); };
      cats.push(el);
      return el;
    }

    /* commande pour faire fuir les chats de la souris : on applique un petit dÃ©placement */
    let mouseX = window.innerWidth / 2;
    window.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      // on convertit chaque chat pour qu'il se dÃ©place horizontalement si la souris est proche
      cats.forEach(c => {
        const rect = c.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const dist = Math.abs(cx - mouseX);
        if (dist < 140){
          // flee: dÃ©placer vers la gauche ou droite selon position souris par rapport au chat
          const dir = cx > mouseX ? 1 : -1;
          // translation logique (en px)
          const delta = dir * Math.max(6, Math.round((140 - dist) / 8));
          c._x += delta;
          // clamp
          c._x = Math.max(0, Math.min(window.innerWidth - rect.width, c._x));
          c.style.transform = `translate(${c._x}px, ${c._y}px) scale(${CSS_CAT_SCALE})`;
        } else {
          // petit retour lent vers baseline
          // noop for simplicity
        }
      });
    });

    /* spawn initial */
    function spawnSomeCats(n=4){
      const baseY = Math.max(120, window.innerHeight - (FRAME_H * CSS_CAT_SCALE) - 140);
      for (let i=0;i<n;i++){
        const x = 40 + Math.floor(Math.random() * Math.max(120, window.innerWidth - 200));
        const y = baseY - Math.floor(Math.random() * 14);
        const row = Math.random() > 0.5 ? 1 : 0; // two example rows
        createCat({x,y,animRow:row,frames:4,speed:160 + Math.round(Math.random()*60)});
      }
    }

    /* nettoyage on unload */
    window.addEventListener('beforeunload', ()=> cats.forEach(c => c.destroy && c.destroy()));

    /* ----------------------------
       Handler du bouton "Oui" : affiche GIF de cÃ©lÃ©bration au-dessus du card
       ---------------------------- */
    yesBtn.addEventListener('click', () => {
      showToast("Oui ! ðŸ’ž", 1200);
      yesBtn.disabled = true;

      // crÃ©er img
      const gif = document.createElement('img');
      gif.src = GIF_SRC;
      gif.alt = 'Celebrate';
      gif.className = 'celebration-gif';
      // initial append to body (pour Ã©viter overflow du card)
      document.body.appendChild(gif);

      // positionner centrÃ© horizontalement par rapport Ã  la card, et juste au-dessus
      const rect = card.getBoundingClientRect();
      // attendre que l'image ait un layout pour mesurer sa hauteur
      requestAnimationFrame(() => {
        const grect = gif.getBoundingClientRect();
        const top = Math.max(8, rect.top + window.scrollY - grect.height - 8);
        const left = rect.left + rect.width / 2 + window.scrollX;
        gif.style.left = left + 'px';
        gif.style.top = top + 'px';
        // show class pour fadeIn
        requestAnimationFrame(()=> gif.classList.add('show'));
      });

      // durÃ©e puis suppression
      const DURATION = 2200;
      setTimeout(() => {
        gif.classList.remove('show');
        setTimeout(()=> gif.remove(), 300);
      }, DURATION);
    });

    noBtn.addEventListener('click', () => {
      showToast("Oh... ðŸ˜¿", 900);
      noBtn.disabled = true;
    });

    /* ----------------------------
       Init sequence
       ---------------------------- */
    (async function init(){
      try {
        await initSpriteSheet();
      } catch(e){
        console.warn(e);
        showToast("Erreur: impossible de charger la sprite (voir console).", 2200);
      } finally {
        // spawn quelques chats aprÃ¨s init (mÃªme si sprite detection a fallback)
        spawnSomeCats(5);
      }
    })();

    /* debug helper : en cas de soucis, check console pour les valeurs de la sprite */
  </script>
</body>
</html>
